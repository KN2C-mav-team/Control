#include "IMU.h"
#include "Control.h"

_IMU Mahony;



void Update_IMU_Data_Mahony(_IMU *IMU,MPU_SENSOR *sen)
{
	HAL_NVIC_DisableIRQ(DMA1_Stream2_IRQn);
	Mpu_update(sen);   //Alireza: update gyro & acc & gravity
	HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
	update_Accel_weight(IMU,sen);
	MahonyAHRSupdateIMU(IMU,sen);
	Update_Euler_angles(IMU,sen);
	
	
}


void update_Accel_weight(_IMU *IMU,MPU_SENSOR *sen)
{

    sen->Accel_magnitude = sqrt(sen->acc_x*sen->acc_x + sen->acc_y * sen->acc_y + sen->acc_z * sen->acc_z);
  
    sen->Accel_magnitude = sen->Accel_magnitude / sen->Gravity; 
    sen->g_print=fabs(fabs(1.0f-sen->Accel_magnitude ));


    sen->g_print=sen->last_g_print+(DT / ( FILTER_G_PRINT + DT)) * (sen->g_print-sen->last_g_print);                
              
    sen->last_g_print=sen->g_print;  
	
	
	if ( Yaw.flag == 0 ){    // moj


																	if(sen->g_print < 0.005f)
																						IMU->Accel_weight=1.0f;
																	else if(sen->g_print < 0.009f)
																						IMU->Accel_weight=0.5f;
																	else if(sen->g_print < 0.016f)
																						IMU->Accel_weight=0.4f;  
																	else if(sen->g_print < 0.021f)
																						IMU->Accel_weight=0.05f;          
																	else if(sen->g_print < 0.027f)
																						IMU->Accel_weight=0.001f; 
																	else if(sen->g_print < 0.029f)
																						IMU->Accel_weight=0.0f;
																}		
	if (Yaw.flag == 1){         // moj
		
																	if(sen->g_print < 0.005f)
																						IMU->Accel_weight=1.0f;
																	else if(sen->g_print < 0.009f)
																						IMU->Accel_weight=0.5f;
																	else if(sen->g_print < 0.016f)
																						IMU->Accel_weight=0.4f;  
																	else if(sen->g_print < 0.021f)
																						IMU->Accel_weight=0.05f;          
																	else if(sen->g_print < 0.027f)
																						IMU->Accel_weight=0.001f; 
																	else if(sen->g_print < 0.029f)
																						IMU->Accel_weight=0.0f;  
																		} 
              
}




void Update_Euler_angles(_IMU *IMU,MPU_SENSOR *sen)
{
	
	  IMU->Pitch = (atan2(2*(IMU->q0*IMU->q1+IMU->q2*IMU->q3),1- 2*(IMU->q1*IMU->q1+IMU->q2*IMU->q2)) * 180.0f)/3.1415f;
    IMU->Roll = (asin(2*(IMU->q0*IMU->q2-IMU->q3*IMU->q1)) * 180.0f)/3.1415f ;
    IMU->Yaw = (atan2(2*(IMU->q0*IMU->q3+IMU->q1*IMU->q2),1- 2*(IMU->q2*IMU->q2+IMU->q3*IMU->q3)) * 180.0f)/3.1415f;  
    
    
    
    if(IMU->last_Yaw - IMU->Yaw < -320)
      IMU->Twokp_Y--;

    if(IMU->last_Yaw - IMU->Yaw > 320)
		  IMU->Twokp_Y++; 
          

		IMU->last_Yaw   = IMU->Yaw;
		
		
		IMU->Yaw = 360*IMU->Twokp_Y + IMU->Yaw;
		IMU->last_Roll  = IMU->Roll;
		IMU->last_Pitch = IMU->Pitch;
		
		
		Calculate_Static_Acc(IMU,sen);

		IMU->Earth_acc_z = 2*(IMU->q1 * IMU->q3 -IMU->q0 * IMU->q2) * sen->acc_x     +     2*(IMU->q2 * IMU->q3 + IMU->q0 * IMU->q1) * sen->acc_y     +     2*(IMU->q0 * IMU->q0 + IMU->q3 * IMU->q3 - 0.5f ) * sen->acc_z;    
		IMU->Earth_acc_z =((-sen->Gravity + IMU->Earth_acc_z)/sen->Gravity)*9.8f +0.07f ;
		
		if(fabs(IMU->Earth_acc_z) <0.02f)
			IMU->Earth_acc_z =0;
		
		IMU->Earth_acc_y = ((2*(IMU->q1 * IMU->q2 +IMU->q0 * IMU->q3) * sen->acc_x     +     2*(IMU->q0 * IMU->q0 + IMU->q2 * IMU->q2 - 0.5f ) * sen->acc_y     +    2*(IMU->q2 * IMU->q3 -IMU->q0 * IMU->q1) * sen->acc_z)/sen->Gravity)*9.8f;   
		IMU->Earth_acc_x = ((2*(IMU->q0 * IMU->q0 + IMU->q1 * IMU->q1 - 0.5f ) * sen->acc_x     +     2*(IMU->q1 * IMU->q2 -IMU->q0 * IMU->q3) * sen->acc_y     +    2*(IMU->q1 * IMU->q3 +IMU->q0 * IMU->q2) * sen->acc_z)/sen->Gravity)*9.8f; 

}


void Calculate_Static_Acc(_IMU *IMU,MPU_SENSOR *sen)
{
	float	tanRoll;
	
	float Roll,Pitch;
	
	Roll = IMU->Pitch;
	Pitch = IMU->Roll;
	
	tanRoll=tan(ToRad(Roll));
		
	IMU->pure_acc_x = -sen->Gravity*sin(ToRad(Pitch));
	IMU->pure_acc_z= sqrt (( (sen->Gravity*sen->Gravity) - (IMU->pure_acc_x*IMU->pure_acc_x) )/ ( (tanRoll*tanRoll) + 1 ) );
	IMU->pure_acc_y=sqrt( (sen->Gravity *sen->Gravity) - ( IMU->pure_acc_x*IMU->pure_acc_x) - ( IMU->pure_acc_z*IMU->pure_acc_z) );
	if(Roll<0)
			IMU->pure_acc_y= -IMU->pure_acc_y;

}






void MahonyAHRSupdateIMU(_IMU *IMU,MPU_SENSOR *sen)
{
	
	float recipNorm;
	float s0, s1, s2, s3;
	float qDot1, qDot2, qDot3, qDot4;
	float _2q0, _2q1, _2q2, _2q3, _4q0, _4q1, _4q2 ,_8q1, _8q2, q0q0, q1q1, q2q2, q3q3;
		
		float q0=IMU->q0;
		float q1=IMU->q1;
		float q2=IMU->q2;
		float q3=IMU->q3;
	
		float gx = sen->gyro_x;
		float gy = sen->gyro_y;
		float gz = sen->gyro_z;
	
		float ax = sen->acc_x/sen->Gravity;
		float ay = sen->acc_y/sen->Gravity;
		float az = sen->acc_z/sen->Gravity;
	if(!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {
		
	// Rate of change of quaternion from gyroscope
	qDot1 = 0.5f * (-q1 * gx - q2 * gy - q3 * gz);
	qDot2 = 0.5f * (q0 * gx + q2 * gz - q3 * gy);
	qDot3 = 0.5f * (q0 * gy - q1 * gz + q3 * gx);
	qDot4 = 0.5f * (q0 * gz + q1 * gy - q2 * gx);

	// Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)
	if(!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {

		// Normalise accelerometer measurement
		recipNorm = invSqrt(ax * ax + ay * ay + az * az);
		ax *= recipNorm;
		ay *= recipNorm;
		az *= recipNorm;   

		// Auxiliary variables to avoid repeated arithmetic
		_2q0 = 2.0f * q0;
		_2q1 = 2.0f * q1;
		_2q2 = 2.0f * q2;
		_2q3 = 2.0f * q3;
		_4q0 = 4.0f * q0;
		_4q1 = 4.0f * q1;
		_4q2 = 4.0f * q2;
		_8q1 = 8.0f * q1;
		_8q2 = 8.0f * q2;
		q0q0 = q0 * q0;
		q1q1 = q1 * q1;
		q2q2 = q2 * q2;
		q3q3 = q3 * q3;

		// Gradient decent algorithm corrective step

		s0 = (_4q0 * q2q2 + _2q2 * ax + _4q0 * q1q1 - _2q1 * ay);
		s1 = (_4q1 * q3q3 - _2q3 * ax + 4.0f * q0q0 * q1 - _2q0 * ay - _4q1 + _8q1 * q1q1 + _8q1 * q2q2 + _4q1 * az);
		s2 = (4.0f * q0q0 * q2 + _2q0 * ax + _4q2 * q3q3 - _2q3 * ay - _4q2 + _8q2 * q1q1 + _8q2 * q2q2 + _4q2 * az);
		s3 = (4.0f * q1q1 * q3 - _2q1 * ax + 4.0f * q2q2 * q3 - _2q2 * ay);
		recipNorm = invSqrt(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3); // normalise step magnitude
		s0 *= recipNorm;
		s1 *= recipNorm;
		s2 *= recipNorm;
		s3 *= recipNorm;

		// Apply feedback step
//		IMU->Accel_weight=1.0f;
		qDot1 -= IMU->Accel_weight * Madwick_Beta * s0;
		qDot2 -= IMU->Accel_weight * Madwick_Beta * s1;
		qDot3 -= IMU->Accel_weight * Madwick_Beta * s2;
		qDot4 -= IMU->Accel_weight * Madwick_Beta * s3;
	}

	// Integrate rate of change of quaternion to yield quaternion
	q0 += qDot1 * (1.0f / sampleFreq);
	q1 += qDot2 * (1.0f / sampleFreq);
	q2 += qDot3 * (1.0f / sampleFreq);
	q3 += qDot4 * (1.0f / sampleFreq);

	// Normalise quaternion
	recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
	q0 *= recipNorm;
	q1 *= recipNorm;
	q2 *= recipNorm;
	q3 *= recipNorm;
	
	IMU->q0 = q0;
	IMU->q1 = q1;
	IMU->q2 = q2;
	IMU->q3 = q3;


}




// Fast inverse square-root
// See: http://en.wikipedia.org/wiki/Fast_inverse_square_root

float invSqrt(float x) 
{
	float halfx = 0.5f * x;
	float y = x;
	long i = *(long*)&y;
	i = 0x5f3759df - (i>>1);
	y = *(float*)&i;
	y = y * (1.5f - (halfx * y * y));
	return y;
}
